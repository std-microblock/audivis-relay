<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Microphone Streamer</title>
    <style>
        body { font-family: sans-serif; text-align: center; padding-top: 50px; }
        #status { margin-bottom: 20px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>Real-time Microphone Audio Stream</h1>
    <p id="status">Status: Disconnected</p>
    <button id="connectButton">Connect and Start Streaming</button>

    <script>
        const connectButton = document.getElementById('connectButton');
        const statusDiv = document.getElementById('status');
        let websocket;
        let audioContext;
        let scriptProcessor;
        let mediaStreamSource;

        const connect = () => {
            websocket = new WebSocket('ws://localhost:9001');
            websocket.binaryType = 'arraybuffer';

            websocket.onopen = () => {
                statusDiv.textContent = 'Status: Connected. Waiting for microphone...';
                console.log('WebSocket connection established.');
                startStreaming();
            };

            websocket.onclose = () => {
                statusDiv.textContent = 'Status: Disconnected';
                console.log('WebSocket connection closed.');
                stopStreaming();
            };

            websocket.onerror = (error) => {
                statusDiv.textContent = 'Status: Connection Error';
                console.error('WebSocket Error:', error);
            };
        };

        const startStreaming = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                statusDiv.textContent = 'Status: Streaming...';
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 48000
                });
                
                // The buffer size affects latency. Smaller buffer = lower latency.
                // Must be a power of 2, from 256 to 16384.
                const bufferSize = 256;

                scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
                mediaStreamSource = audioContext.createMediaStreamSource(stream);
                
                scriptProcessor.onaudioprocess = (event) => {
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        const pcmData = event.inputBuffer.getChannelData(0);
                        // Convert float32 PCM to int16 PCM
                        const pcm16 = new Int16Array(pcmData.length);
                        for (let i = 0; i < pcmData.length; i++) {
                            let s = Math.max(-1, Math.min(1, pcmData[i]));
                            pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }
                        websocket.send(pcm16.buffer);
                    }
                };

                mediaStreamSource.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

            } catch (err) {
                statusDiv.textContent = 'Status: Microphone access denied.';
                console.error('Error accessing microphone:', err);
            }
        };

        const stopStreaming = () => {
            if (mediaStreamSource) {
                mediaStreamSource.disconnect();
                mediaStreamSource = null;
            }
            if (scriptProcessor) {
                scriptProcessor.disconnect();
                scriptProcessor = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
        };

        connectButton.addEventListener('click', () => {
            if (!websocket || websocket.readyState === WebSocket.CLOSED) {
                connect();
            }
        });
    </script>
</body>
</html>